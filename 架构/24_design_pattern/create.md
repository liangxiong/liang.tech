# 创建类设计模式
### 简单工厂  选择实现
- 本质：选择合适的实现类,。提供一个创建对象实列的功能，而无须关心其具体实现
- 场景：
    - 客户端想要完全封装隔离具体实现
    - 对外创建对象的职责集中管理和控制
- 角色：
    - client
    - factory
    - interface
    - implement
- 流程：
    - client 调用简单工厂中创建方法
    - 工厂选择并创建具体实现对象
    - client 调动接口的方法，执行
- 优点：    
    - 帮助封装：实现了组件的封装，让组件外部真正面向接口编程
    - 解耦：client 和 具体实现类的解耦
- 缺点：
    - 当实现类增多时，还是需要客户端去做选择

### 工厂方法 factory methory  延迟到子类来选择实现
- 定义用于创建对象的接口，让子类决定实例化哪 个类，使一个类的实例化延迟到工厂子类    、
- 场景
    - 需要创建某个接口的对象，但是又不知道具体的实现
- 角色
    - 产品 product
    - 具体产品 concrete product
    - 创建器 creator
    - 具体创建器 concrete creator
- 流程：
    - client 初始化具体工厂的子类对象，再调用创建某个产品的方法
    - 工厂子类，创建真正的产品
    - client 调用产品对象的方法
- 优点
    - 不知道具体实现时产品
- 缺点
    - 具体产品和工厂方法耦合

### 抽象工厂 abstract factory 选择产品族的实现
- 场景：
    - 面向产品接口编程，产品有多个系列
- 角色
    - 抽象工厂 abstract factory
    - 具体工厂 concrete factory
    - 抽象产品 abstract product
    - 具体产品 concrete product
    - client
- 优点
    - 分离产品的接口和实现 （工厂都有的优点）
    - 切换产品族非常简单
- 缺点
    - 非常不容易扩展新产品
    - 类层次有点复杂

### 建造者 builder：分离整体的构建算法和部件构造，
- 场景：
    - 相同的方法，不同的执行顺序，产生不同的事件结果
    - 产品类的创造过程非常复杂
- 注意：
    - 他关注的是零件的类型和装配工艺的顺序导致结果的不同。
- 角色
    - builder 抽象建造者
    - concreteBuilder 具体建造者
    - product 产品类
    - director 指导者  持有建造者和数据，进行构建的步骤 调用建造者
- 流程：
    - client  创建 具体builder ， 再创建director，把builder 传入 director
    - director  构建不同的部件  调用build方法返回 product 对象
- 优点：
    - 便于控制创建过程的细化
    - 建造者独立，容易扩展
- 注意：
    - 使用连缀写法
    - 构造器私有，只能让builder返回创建好的对象

### 单例模式：控制实例数目
- 分：
    - 懒汉：
        - 用的时候，去实例化
    - 饿汉
        - 一开始就实例化，由于反射可以破坏构造函数
        - 使用枚举类
- 优点：
    - 只有单列，减少了内存，性能开销，参考 struct spring的实列
- 缺点：
    - 要求生成唯一序列号，共享数据
    - 创建的对象消耗资源很大
    - 需要定义大量静态常理和方法的环境
- 如何破坏单列：
    - 基于反射的，序列化

### 原型模式：property 克隆生成对象
- 用原型实例指定创建对象的宗磊，并通过拷贝这些原型创建新对象
- 通过克隆来创建新的对象实例，复制原型实例属性的值
- 用原型实列指定创建对象的种类，并且通过拷贝原型创建新的对象
- 场景：
    - 一个对象多个修改者
    - 需要实列化的类是运行时动态指定，通过克隆得到实例
    - 系统想要独立于它想要对象时，使用原型，让系统只面向接口编程，通过克隆得到实例
- 角色
    - 客户端  client
    - 原型  prototype  
    - 具体原型 concretePrototype
- 优点：
    - 客户端隐藏具体的实现类，只知道原型接口的
    - 运行时动态改变具体的实现类型,通过注册符合原型接口的实现类
    - 性能优良，不需要构造函数（缺点）
- 小缺点：
    - clone 的对象，包含引用类型的对象，会比较麻烦
    - clone 的对象不能用final字段
- 注意：
    - 不会执行构造函数，直接是内存二进制流的拷贝
    - 如果需要深拷贝，对于非 基本类型，String。对于包含引用的对象，也需要实现cloneable 接口
    - 拷贝分：
        - 浅拷贝：只复制克隆按值传递的数据
        - 深拷贝：除了浅克隆，还负责克隆引用类型的数据

## uml图
<img src = 'http://res.liang3307.tech/liang.tech/career/24_design_pattern/res/create.png'>
