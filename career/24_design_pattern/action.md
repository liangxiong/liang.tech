# 行为类设计模式
### 备忘录 memento 保存和恢复内部状态
捕获对象内部的状态，存储到外部，不破坏封装性，在以后某个时候，将该对象状态恢复到备忘录锁保存的状态
- 场景：
    - 需要保存和恢复数据的相关状态
    - 提供一个可回滚的操作
    - 数据库连接的事物管理就是用备忘录模式？
    - 需要监控的副本场景中
- 角色
    - 发起人 originator
    - 备忘录 memento 提供窄接口    
    - 备忘录管理员 caretaker
- 流程：
    - 创建备忘录：
        - client 创建发起人，调用发起人的业务处理方法
        - client 调用发起人的createMemento
        - client 调用 管理者保存 memento
    - 恢复：
        - client 调用管理者的retriveMemento 获取元素
        - 调用原发器的 setMemento方法，让原发器恢复状态
- 优点：
    - 使用备忘录对象，封装业务对象的内部状态
    - 窄接口和宽接口
        - 窄接口 保证了只有业务对象才可以访问备忘录对象的状态
- 缺点：
    - 导致高开销：对备忘录对象的存储和恢复，就是缓存功能
- 注意：
    - 备忘录的生命周期，如果确定用不到，赶紧回收
    - 数量的控制
    - 不要在频繁变动中使用备忘录模式
- 变种：
    - clone，多状态保存

### 命令  command 封装请求 api采用 ************  jdocker
- 场景
    - 需要抽象出执行的动作，参数化这些对象
    - 需要支持取消，事物操作
    - 支持系统奔溃时，命令能够重新执行

- 角色
    - 发动者 Invoker   接收命令，开始执行命令的角色
    - 命令 Command   执行的命令，不过只是命令的传递，参数
    - 具体命令 ConcreteCommand
    - 接收者 Receive  接收命令，执行命令，具体执行命令的对象
- 流程
    - client 创建接受者，创建命令对象，设置命令对象和接受对象的关系
    - 创建 Invoker 对象，设置命令对象到 invoker
    - 调用 invoker 的方法，触发执行命令  -> command -> receive
- 优点
    - 类间解耦 ： 客户端和接受者解耦，只需要执行对应的命令
    - Command 子类非常容易扩展
    - 很自然进行复合，动态控制
- 缺点
    - 类膨胀大

### 解释器 interpreter 分离实现 解释执行
- 场景：
    - 问题，可以用抽象语法树时，可抽象成解释器来解决
    - 一个简单预发需要解释的场景
- 角色:
    - 环境角色 context  存放数据
    - 抽象解释器 abstractexpression
    - 终结符解释器 termminal expression
    - 非终结符解释器 nonterminal expression
    - 按代码分：
        - 解析器：把表达式解析成抽象语法树
        - 解释器：解释执行抽象语法树
- 流程：
    - client 创建上下文，创建多个解释器对象，组合抽象语法树
    - 调用解释器的解释操作，解释器：通过上下文来存储和递归调用后续的解释器
- 优点：
    - 简单语法分析工具，优点：扩展性，修改语法规则只是修改响应的终结符表达式，扩展 只要增加非终结符类
    - 易于扩展新语法，增加新的解释器
- 缺点：
    - 引起类膨胀
    - 如果语法复杂：采用递归调用，效率问题
- 注意事项：
    - 重要模块不要使用，可以使用shell，jruby，groovy等脚本语言来代替解释器
    - <font color=#D2691E> 解析工具包：expression4j,mesp(math expression string parse),jep  </font>

### 迭代 Iterator 控制访问聚合对象中的元素
- 功能：
    - 提供聚合对象的迭代访问
    - 同一个聚合，提供多个遍历
    - 多态迭代：为不同的聚合结构，提供统一的迭代接口
    - 过滤迭代：迭代器内copy一份数据
- 场景
    - 提供访问聚合对象的内容，但是有不想暴露他的内部表示时
    - 多种遍历方式访问聚合对象
    - 遍历不同聚合对象提供统一的接口，使用迭代器模式
- 角色
    - 抽象迭代器 Iterator
    - 具体迭代器 ConcreteIterator
    - 抽象容器 Aggregate
    - 具体容器 ConcreteAggregate
- 优点
    - 更好的封装，访问聚合对象的内容，而无须暴露聚合对象的内部
    - 聚合对象的内容和具体迭代算法分离开
    - 可以用不同的遍历方式来遍历聚合
    - 简化了聚合对象定义接口，不需要去定义遍历接口
- 分：
    - 内部迭代器：js的写法，callback形式
    - 外部迭代器：java写法

### 中介者 mediator  封装交互
- 场景
    - 类之间出现蜘蛛网结构
- 角色
    - 抽象中介者 Mediator
    - 具体中介者 ConcreteMediator
    - 同事角色 Colleague
- 流程:
    - client  调用同事A的方法，同事A调用中介者的方法
    - 中介者 调用同事B，C的方法
- 优点:
    - 减少类间的依赖，一对多的依赖变成一对一依赖 ，同事间的依赖 变成 只依赖中介者。
    - 也验证了业务复杂了中间多加一层
- 缺点:
    - 问题只是抛给了中介者，如果固定不变的一对多关系，引入了中介者，导致更复杂

### 观察者 Observer  触发联动
- 场景
    - 一个业务有两个方面，一方面的操作依赖另外一方面的状态变化
    - 跨系统的消息交换场景
    - 关联行文场景
    - 时间触发场景
- 角色
    - 观察对象 subject  observable
    - 具体观察对象 concreteSubject
    - 观察者 observer
    - 具体观察者 ConcreteObserver  订阅到观察者
- 流程：
    - client 创建目标对象，观察者对象
    - 目标对象注册观察者对象
    - 改变目标对象的状态 -> 通知所有注册的观察者
- 优点
        - 观察者和被观察者之间解耦
        - 建立触发机制，动态联动
- 缺点
    - 一个被观察者和多个观察者，开发调试比较复杂
    - 一个观察者卡主，会影响全局，考虑异步
    - 多级触发效率更恐怖，考虑异步
    - 引起无所谓的操作，subject 简单的变化

### 状态 state：根据状态来分离和选择行为
- 场景：
    - 行为取决于状态
    - 许多的分支语句，而分支依赖于该对象的状态
    - 手机号套餐：订阅，非订阅
- 角色：
    - Context 串联各个状态的过渡，数据的存放
    - State
    - ConcreteState 业务逻辑
- 流程：
    - client 创建context，context 先调用 state_a
    - state_a 调用逻辑，context 登记设置 state_b
    - state_b 调用逻辑
- 优点
    - 分离了状态和行为，分布到不同的状态类中，结构清晰，避免了if  else 语句，更好的扩展
    - 体现了开闭原则，单一职责原则，每个状态都是子类
    - 封装性非常好
    - 显示化状态转换
- 缺点
    - 一个状态一个处理类，类的爆炸
- 注意：
    - 状态转换：
        - 不需要进行扩展，就在上下文中进行状态的维护
        - 状态的转换取决于前一个状态的处理结果或者外部数据，为了灵活性，放到状态处理类中维护
- 精髓：
    - 封装状态，暴露行为

### 策略 Strategy，分离算法选择实现，相同行为不同实现
- 场景
    - 多个类，只有在算法或行为上稍有不同的场景
    - 一个类型算法，会有多种实现
    - 需要封装算法，有与算法相关数据情况下，使用策略模式来避免暴露这些数据结构
    - 算法能够自由切换或屏蔽算法规则
    - 定义了行为，通过if else 来选择：内存少的可以使用SlowButLessMemoryStrategy( 速度慢但省内存的策略),内存多的使用：FastButMoreMemoryStrategy (速度快但耗内存)
- 角色：
    - 策略 Strategy
    - 具体策略 ConcreteStrategy
    - 上下文 Context  持有策略，委托作用，负责算法的替换
- 过程：
    - 1：选择具体的策略对象
    - 2：创建上下文，把策略对象设置到上下文中
    - 3：调用上下文的方法
    - 4：上下文 转调具体策略的方法 （上下文当成参数传递给策略对象）
- 优点        
    - 编程：将算法部分和其他部分分离开来，定义一系列算法，方便替换算法
    - 避免使用if
    - 策略是平等的，可以替换，也方便扩展
- 缺点:
    - 策略多了，需要客户端来决策。当有4个或以上的策略，考虑混合模式，自动选择，解决策略类膨胀或对外暴露的问题，

### 模板 Template  固定流程骨架
定义操作中的算法骨架，将一些步骤延迟到子类中
- 场景    
    - 需要固定流程骨架，控制子类的扩展
    - 多个子类公共方法，逻辑流程基本相同
    - 核心的逻辑算法设计为模板方法，周边的细节功能由子类实现 （抽象类的功能）
    - 重构中常用
- 角色
    - 抽象类 AbstractClass
    - 具体类 ConcreteClass
- 优点：
    - 封装不变部分，扩展可变部分
    - 提取公共部分代码，便于维护
    - 行为父类控制，子类实现
- 缺点：
    - 子类实现影响父类的结果，产生影响，这会增加阅读代码难度
    - 骨架的升级：需要特别总结好：变与不变部分
- 案例：
    - 代码中的排序


### 访问者 Visitor：预留通路，回调实现
作用于对象结构中的各元素，使你可以在不改变各元素的前提下定义作用于这些元素的新操作
- 场景
    - 数据结构和处理分开
    - 同一个元素进行不同而且不相关的操作，为了避免对象类变得杂乱
- 角色
    - 访问者 Viditor
    - 具体访问者 ConcreteVisitor
    - 元素 Element
    - 具体元素 ConcreteElement
    - ObjectStructure 遍历所有元素，调用元素的accept
- 流程：
    - 元素回调访问者的visit方法，二次分发
    - 双重分发 element accept visitor  而visitor又vist element
- 优点
    - 符合单一原则，扩展性好，灵活，很容易去增加访问者
    - 分离无关行为
- 缺点
    - 具体元素对访问者公布细节，访问者得知元素的具体细节
    - 具体元素变化会比较困难，导致你的访问者都需要变化
    - 依赖具体元素，违反依赖倒置原则

### 责任链模式 Chain of Responsibility 分离职责，动态组合
一个请求，有多个对象有机会来处理这个请求，单不知道具体谁来处理他的请求，组成一条职责链
- 场景
    - 多个对象可以处理同一个请求，但是具体那个对象处理请求，需要运行时刻动态确定
- 角色
    - 处理者 Handler    
    - 具体处理者  ConcreteHandler
    - 请求者 Client  组装处理链
- 流程：
    - cleint 组织好起始的 handler 设置好下一个节点
    - client 执行 handler
- 优点
    - 请求人和处理请求人松散耦合
    - 动态组合职责
    - 每个矗立着专注于本身自己的职责
- 缺点
    - 产生大量细粒度对象
    - 由于事前不确定处理对象，有可能会造成事件处理延迟，性能，不一定处理
    - 调试麻烦，一条链
- 注意
    - 节点数量控制，避免形成环装链


### uml图
<img src = 'http://res.liang3307.tech/liang.tech/career/24_design_pattern/res/action_1.png'>
<br />
<img src = 'http://res.liang3307.tech/liang.tech/career/24_design_pattern/res/action_2.png'>
