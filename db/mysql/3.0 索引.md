# 索引
- 是一种数据结构，能够帮助我们快速的检索数据库中的数据
- 作用：
  - 检索：提⾼数据检索的效率，降低数据库的IO成本，
  - 排序：通过索引列对数据进⾏排序
    - 被索引的列会⾃动进⾏排序
- 缺点：
  - 占据磁盘空间
  - 降低更新表的效率

## 种类：
- 聚集索引
  - 必须有主键，唯一
    - 如果没主键，则使⽤用唯⼀索引建⽴聚集索引
    - 如果还没主键，则内部创建隐含的长整型值
  - 叶⼦节点会存储整行的数据
  - 辅助索引：存储的是主键值
  - 有序
  - 注意：
    - 如果主键使用uuid，会导致辅助索引很大

- 非聚集索引 辅助索引 二级索引
  - 数据和索引不在一起
  - 完整的数据需要回表查询

- 单列列索引
  - 主键索引

  - 普通索引 alter table table_name add index idx_name (c1)
    - 允许有空值，重复值

  - 唯一索引 alter table table_name add unique index uk_name (c1)
    - 唯一，允许有空值

- 组合索引 alter table table_name add index idx_name (c1,c2)
  - 遵循最左前缀原则
  - 从左到右匹配，直到遇到范围查询截止后续的字段使用索引（> < between like !=）
  - 索引上多个范围查询，只有最左原则的第一个字段使用到索引，后续的字段回表再过滤

- 全文索引 alter table table_name add fulltext
  - MyISAM引擎, InnoDB(>5.6)
  - 在索引中优先级最⾼

- 空间索引

## 索引其他问题
- 回表查询

- 索引合并
  - 使用多个二级索引，而不是平常的 读取一个二级索引，回表查询聚集索引过滤

  - Intersection合并：交集 where key1 = 'a' AND key3 = 'b';
    - 优势：读取二级索引的操作是顺序I/O, 而找到多条主键的回表查询是随机I/O
    - 前提条件：
      - 二级索引列是等值匹配的
      - 联合索引中的每个列都必须等值匹配，不能出现只匹配部分列 和 范围匹配
        - 因为：
          - 以上两种情况下，查询的主键值是排序好的。取交集的时间复杂度：O(n)，否则耗时 O(m * n)
      - 主键可以进行范围匹配

  - Union合并：并集 where key1 = 'a' OR key3 = 'b'
    - 前提条件：
      - 二级索引列是等值匹配的情况
      - 联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况
      - 主键列可以是范围匹配
      - Intersection 索引合并的条件
    - 最终看优化器的评判

  - Sort-Union合并
    - Union合并的升级
    - 操作步骤中：每个索引返回的主键较少，先排序后，再合并



## 索引数据结构
- B Tree
  - 叶子和⾮叶⼦节点都存储数据
  - 多叉
  - 特点
    - 天然有序
    - 左子节点小于父节点、父节点小于右子节点
  - 适合场景
    - 排序
    - 范围查询

- B+ Tree
  - 叶子节点才存储数据
  - ⽽且存储的数据是整行数据，这些数据都是有指针指向，也就是有顺序的
  - 叶子节点的最后一个索引会指向下一个叶子节点的第一个索引：有序链表
  - 数据结构动画：https://www.cs.usfca.edu/~galles/visualization/Algorithms.html

- B B+ Tree 总结:
  - 三层树结构--支撑可以达到20G
  - 四层树结构--⽀撑的数据可以达到⼏十T


- Hash:
  - key-value存储数据的结构
  - 适合等值查询，kv的结构

- 有序数组
  - 适合：等值查询和范围查询场景中的
  - 在更新或插入时：必须挪动后面的记录，适合静态数据，不会变好的
  - 二分查找方法，时间复杂度：O(log(N))


### 创建具体索引的判断依据：
- 那些情况创建索引的背景
  - where: 频繁作为查询条件的字段  
  - columns: 频繁查找字段: 覆盖索引 select
  - join on: 多表关联查询中，关联字段应该创建索引, on 两边都要创建索引
  - order by: 排序的字段
  - group by: 查询中统计或者分组字段，应该创建索引
  - 尽量用组合索引
  - 考虑列的基数，不重复数据的个数
  - 索引列的类型尽量小：操作比较快（cpu），占用的空间小

- 案例：
  - 身份证：前后倒置，再使用前缀索引
  - ipv4：转成long 创建索引

- 哪些情况不不需要创建索引
  - 表记录太少
  - 经常进行增删改操作的表
  - 频繁更更新的字段
  - where条件⾥使⽤频率不高的字段
  - 区分度低：如性别
  - 不建议无序的值作为索引

- 索引失效
  - 组合索引，最左匹配，范围查询后面的列失效（> < between like !=）
  - 函数，隐式类型转换
