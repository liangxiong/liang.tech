# 结构类设计模式
### 适配器 adapter  转换匹配，复用功能
将一个类的接口转化成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作
- 分
    - 类适配 (使用继承)
    - 对象适配 （使用委托）
- 场景：
    - 已经存在的类，接口不符合你的需求，接口又不能修改
    - 想创建一个复用的类，这个类和不兼容的类一起工作。
    - 存在的一些业务子类，需要用对象适配器，直接适配父类
- 角色
    - 目标角色 Target    定义所需要的方法
    - 源角色     adaptee
    - 设配器角色 adapter
- 流程：
    - client 调用适配器实现的功能
    - 适配器调用 被适配者的功能
- 优点
    - 提高类的复用度，更好的扩展
    - 增加类的透明，做了业务，client 不知道这是新的类
- 缺点
    - 过多使用，看起来调用的是这个接口，内部是用别的接口实现。会让系统凌乱。被适配者和适配者相近，缺有2份实现
- 注意：
    - 不要一开始就想到用，当过多适配时，考虑重构

###  桥接 桥梁 bridge  分离抽象和实现
抽象和实现解耦，使两者独立变化
jdbc: 使用者，和开发者的分离
类的功能层次和类的实现层次分开
- 场景
    - 抽象部分和实现部分都能够扩展的情况，让两部分独立的变化
    - 接口和抽象类不稳定的场景
    - 采用继承，会产生很多子类，重用要求高，分出来的粒度要求更细
- 角色
    - 抽象部分接口 abstraction
    - 扩展抽象部分的接口，refinedAbstraction extends abstraction
    - 定义实现部分的接口  implementor
    - 真正实现Implementor接口的对象 concrete Implementor
- 流程
    - client 创建一个具体实现对象，传入到抽象部分对象
    - 调用某功能的方法，调用父类的方法，转调到真正的实现上去
- 优点
    - 抽象和实现分离，更好的扩展，动态的切换实现
    - 减少子类
    - 注意
        - 主要考虑如何拆分抽象和实现

### 组合: Composite  统一叶子和组合对象
单个对象和组合对象具有一致性：组合成一个树，客户端透明的使用
递归的对象结构
- 场景：
    - 表示整体和部分的场景， 树形菜单，文件夹管理
    - 希望统一地使用组合接种的对象
    - 从一个整体中能够独立出部分模块或功能的场景                
- 角色：
    - 抽象构建 component
    - 树叶 leaf
    - 树枝  composite
- 优点：
    - 定义了基本对象和组合对象的类层次结构，并且从外观上统一起来
    - 简化了客户端的调用，高层调动清晰，简单
    - 节点自由增加
- 缺点：
    - 有点不是面向接口编程，你到最后必须去判断实现类，和依赖倒置原则冲突
- 注意：
    - 只要是树形结构，就要考虑组合模式
    - 局部和整体关系
    - 安全性和透明性：更偏向透明性
        - 安全性：叶子节点也有树枝节点的功能，可抛出异常
        - 透明性：客户端透明，2种分类一样的使用

### 装饰器 decorator  动态组合
动态给一个对象添加功能，优于继存
动态是手段，组合是目的：
- 分：
    - 动态功能组合
    - 动态对象组合
- 场景
    - 不影响其他对象的情况下，动态透明的方式给对象添加职责
    - 不适合使用子类来进行扩展功能的时候
- 角色
    - 组件 component
    - 具体组件  concreteComponent
    - 抽象装饰物 decorator  继承 component
    - 具体装饰物 concreteDecorator
- 优点
    - 比继承更灵活，继承是静态的，子类都会有这样的功能，装饰器可灵活增加卸载功能, 更容易复用
    - 简化高层决策，不需要高层列出所有的功能，只需要定义最基本的，后期按需增加
- 缺点
    - 会产生很多细粒度对象，注意装饰器类的爆炸，降低复杂度

### 门面/外观：facade   封装交互，简化调用
- 精辟
    - 封装交互，简化调用。最少知道原则
    - 为一组接口，提供统一组件
- 场景：
    - 为一个复杂的系统，提供一个简单的接口
    - 想让客户程序和抽象类的实现部分松散耦合
    - 构建多层的系统，考虑使用外观
- 角色
    - Client
    - Facade
    - 其他业务角色
- 流程：
    - client 调用facade的方法
    - facade 调用 模块a,b,c 的方法后返回结果
- 优点：
    - 松散了客户端与子系统的耦合关系，依赖的门面，而不是门面后的各个子系统
    - 简单易用，不管系统内部如何变化，不影响外部调用门面
    - 提高安全性：可在门面做安全控制
    - 更好的划分访问层次：门面是给系统外部使用，接口是给内部使用
- 缺点:
    - 不符合开闭原则
    - 容易让门面，职责会比较重
- 注意点：
    - Facade 不参与子系统的业务逻辑，而是为了让外部减少与子系统内部多个模块的交互，松散耦合

### 享元 flyweight： 分离和共享
分离对象中变与不变的部分，运用共享技术有效地支持大量细粒度的对象
- 角色：
    - 抽象享元角色 Flyweight
    - 具体享元角色 ConcreteFlyweight
    - 不可共享享元角色 unsharedConcreteFlyweight
    - 享元工厂 FlyweightFactory
- 流程：
    - client 通过享元工厂创建享元对象
    - 如果工程存在，直接返回享元对象
- 场景
    - 系统中存在大量相似细粒度对象
    - 创建耗时对象
    - 缓冲池
    - 一个对象大多数状态可转变为外部状态，由于内部状态很少 使用享元
- 优点
    - 减少对象创建，降低内存占用，增强性能
- 缺点
    - 提高了复杂性，提炼出内部外部状态，减少对象创建
- 注意：
    - 线程安全：内部状态不应该被外部状态改变
    - 工业级考虑：动态控制 实例数量，动态分配实例提供给外部使用

### 代理 Proxy：控制对象访问 使用委托模式
- 场景：
    - 对象在不同地址空间，在远程
    - 创建开销很大的对象，懒加载，先给你虚个对象出来
    - 需要对原始对象进行访问控制时
    - 需要在访问对象执行附加操作时
- 分：
    - 实现分：
        - 静态代理
        - 动态代理 ： 不改变已有代码结构下，增强或控制对象的行为
    - 业务总结分：
         - 虚代理：根据需要创建大对象
        - 远程代理：隐藏对象在不同地址空间的实时
        - 同步代理：创建完，同步到不同机房
        - copy-on-wirte:  写时copy
        - cache 代理：为昂贵的操作提供临时的高速存储空间
        - 保护代理：访问真实对象的前后，执行鉴权，审计操作。防火墙代理
        - 智能指引：和保护代理类似，执行额外的事情，比如：引用计
    - 角色
        - 抽象主题 Subject 是一个业务功能接口
        - 具体主题角色 RealSubject
        - 代理角色 Proxy
    - 流程
        - client 调用代理对象方法
        - 事前：转调具体目标对象前，执行功能
        - 转调具体的目标对象进行功能处理
        - 事后：转调完，可执行功能
        - 异常：捕获异常处理
    - 优点：
        - 职责清晰，高扩展性
        - 插拔，智能化
    - 注意：
        - aop框架：Spring Aop， AspectJ
            - 切面 Aspect
            - 切入点 JoinPoint
            - 通知 Advice
            - 织入 Weave
### uml图：
<img src = 'http://res.liang3307.tech/liang.tech/career/24_design_pattern/res/structure.png'>
